# 动态化

市场上常用的动态化框架方案两种：React Native 和 Flutter

我司的手百动态化框架：San

阿里的动态化框架：Weex

美团的动态化框架：MRN Mach（美团外卖）

## 1. 动态化与NA方法的比较

| 优势                                   | 劣势                                                   | 解决                               |
| -------------------------------------- | ------------------------------------------------------ | ---------------------------------- |
| 迭代效率快，业务代码单端开发，双端生效 | 兼容性风险，Android端机型适配问题                      | 关注市场主流机型                   |
| 支持热修复，修复问题，无需依赖发版     | 性能折损，与NA端相比有性能diff                         | 推动架构层优化，减少视图的重复创建 |
| 适合变动频繁的业务，用于ABTest         | NA的核心业务与原生能力迁移成本高（例如地图，带有图区） | 渐进式优化                         |

## 2.React 与 San框架对比（[San 为什么会这么快](https://efe.baidu.com/blog/san-perf/)）

- 在创建大量的行数据、刷新局部数据、交换行数据时，San的性能优于React（3000节点数据渲染，San框架 717.58ms，Hippy 1117.3ms）
- San引入了**预热机制**，模板确定时，提前做一遍，避免渲染时，重复做。对以下可以预热：
  - 静态属性
  - 保存属性操作函数
  - 对for，if这些提前选择ANode节点对应的实际类型
- San更**轻量**，做减法，体积大概是64KB（3.10.0）；React 128KB（17.0.1），Vue 92KB（2.6.12）
- **兼容性好**，如果遇到兼容问题，在公司内部能够迅速解决

# 动态化领域的问题

- 如何渲染控件
- web和Native通信，采用jsbridge scheme的方式？

url scheme: web端与native首先协商好通信中使用的url的格式，紧接着web端通过一定的方式将url发送出去，最后native层捕获url，并进行分析后再去调用原生方法。这种方法也是目前被广泛使用的方式。

React Native中，使用scheme进行跳转

# 业务

## 难点1 数据打通

现状：

- 地图的数据结构复杂，包括纯业务数据，图层数据等
- 内部使用PB数据结构，iOS内页面之间用指针传递；Android是用对象传递；而前端使用JSON格式数据
- 市场上暂无 PB 转 JSON 或者 JSON 转 PB的库

思考：

| 方案                                             | 优点                                         | 缺点                                                         |
| ------------------------------------------------ | -------------------------------------------- | ------------------------------------------------------------ |
| case by case：针对各个场景，人肉解析             | 解析更精准，无多余字段                       | 耗时长，容易出错                                             |
| parse in runtime：运行时解析，利用运行时方法解析 | 泛化能力强，全量解析                         | 大量的冗余字段；<br>或引入内存问题；<br>前端提取字段慢，平均耗时约200~300ms |
| runtime & cutting：运行时解析 & 剪枝策略         | 泛化能力强，对冗余字段进行剪枝<br>子线程处理 | -                                                            |

第一个想到的是，parse in runtime，但是通过实际操作发现，在耗时和数据可用性上，有很大的问题。引入了两个手段：

- 前置数据转换时机
- 子线程解析
- 剪枝策略（对于空元素的数组、字典，还有空字符串，不再向前端透传）



## 难点2 动态化场景选择

|            |                                                  |               | 地图的特点           |
| ---------- | ------------------------------------------------ | ------------- | -------------------- |
| 页面动态化 | 全页面使用动态化                                 | 少量使用，10% | 不带图区             |
| 局部动态化 | 局部使用动态化，动态化卡片与NA卡片混合（列表页） | 大量使用      | 带图区，耦合地图能力 |

### 局部动态化引入的问题

1. 列表页，如何兼容NA卡片

引入虚拟列表，将NA卡片也虚拟为一个动态化节点，列表里包括了NA卡片和动态化卡片

2. 节点复用

每个模板有个标识ID，系统的ID复用

3. 大量卡片，构造AST树性能慢

节点预渲染（静态值提前渲染），复用渲染树等等

4. 局部刷新

当某个卡片刷新时，只刷新对应节点上的UI



## 业务问题（可能）

- 在使用runtime方法的时候，如何重载get和set方法的（小红书）

- 高度依赖服务端的动态计算，列表页如何正确展示？

多线程同步方案

- 如何评价你们的项目达到了预期的效果呢？

动态化的目的，主要是在尽可能保持原生效果和交互的前提下，加速产品迭代，减少开发成本，降低线上风险。

在切换至动态化框架以后，

产品迭代速度提升40%，平均开发周期缩短了7天左右，部分轻需求实现天级迭代和上线；

另外，由于支持动态修复，我们在上线以后，也修复了数个紧急问题，

# 收益

## 产品

- 实时公交、UGC全量切入，跨城结果页切入80%
- 通过ABTest的方式，投放到市场
- PV平均增长率0.2%，留存率持平

## 技术

- Bundle下载成功率，99.98%，接近100%
- 引入预渲染方案，iOS提升 20%， 安卓 提升25%
- 引入虚拟列表、对逻辑节点（`if` 判断和 `for`循环）减少嵌套层级，内存占用减少40%
- 列表滑动优化：40帧 -> 60帧