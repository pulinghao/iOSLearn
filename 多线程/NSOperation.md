# 核心概念

将“操作”添加到队列中。是一个抽象类，不能直接使用。定义子类公有的属性和方法

子类：

- NSInvocationOperation 
- NSBlockOperation

## **NSInvocationOperation**

- start方法会在当前线程执行和调度。如果在主线程，就会阻塞主线程

## **NSBlockOperation**

- `blockOperationWithBlock`默认在**主线程**
- 通过 `addExecutionBlock` 添加的任务，会开辟多个子线程
- start 会阻塞当前线程
- 任务多了，就不确定哪个会在主线程中执行了

# **NSOperationQueue**

- 将任务添加到队列的方法，自动是在子线程中执行，不会卡死主线程
- 本质上是GCD面向对象的封装
- 最大并发数

在设置最大并发数时macConcurrentOperationCount。例如设置为2。此时活跃的线程一共有主线程、线程1、线程2。但是也会有可能出现线程3，执行任务。原因在于在NSOperation中，任务执行完成后，系统会回收线程。但此时只要线程池中，有多余线程，就会去取新的线程出来。所以可能出现新的线程。但是再同一时间里，始终只有两个线程在运行。

PS：线程数有系统决定，用户决定不了

6、挂起

1）挂起时，正在线程上执行的操作不会暂停！挂起的是队列

2）如果队列本来就是挂起的，那么就是始终挂起的。添加了任务，也会处于等待状态

7、操作数 operationCount

队列中的操作数

8、取消

1.队列挂起的时候,不会清空内部的操作.只有在队列继续的时候才会清空!

 2.正在执行的操作也不会被取消!

9、依赖`addOperations: waitUntilFinished`

这个接口，如果后面的waitUntilFinished的参数设置为YES，就会卡住**当前**线程。

如何判断卡不卡主线程？只要往视图里面，拖入一个scrollView的控件，在运行的时候，看能否拖动这个控件即可。

如果产生循环依赖，A依赖B，B依赖A。不会造成死锁，但是会造成队列不工作

