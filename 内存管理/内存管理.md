# 内存管理

## ARC

## MRC

### 初始化时，self.A = [[NSObject alloc] init]

- 引用计数为1

### 赋值

- 类的属性赋值 object.A = A

	- 1. 调用setProperty
	- 2. 对应地址的extra_rc加1

- 局部变量赋值

	- extra_rc不增加

### retain

- 手动让extra_rc + 1

### retainCount

- 返回的是extra_rc + 1，不是extra_rc。所以即使引用计数为0，调用这个方法时，仍然是1

### release

- 手动让extra_rc - 1

## autoreleasepool

首先，先明确，`autoreleasepool`和`autorelease`对象，前者是管理后者的一个内存管理池。也就是说，autoreleasepool是管理autorelease对象的。



autorelease对象有哪些？

- 图像文件读入到NSData对象，并生成UIImage对象，改变该对象尺寸后生成新的UIImage对象
- NSMutableArray中的arrayWithCapacity类方法

```objective-c
id array = [[NSMutableArray alloc] arrayWithCapacity:1];

//等价于
id array = [[[NSMutableArray alloc] arrayWithCapacity:1] autorelease];
```

- `stringWithFormat`创建的字符串

总结来说：

通常<font color='red'>**非alloc、new、copy、mutableCopy**</font>出来的对象都是autorelease的，比如`[UIImage imageNamed:]`、`[NSString stringWithFormat]`、`[NSMutableArray array]`等。（会加入到最近的autorelease pool哈）

> 所以哦，不是autoreleasepool可以自动监测对象的创建，而是你对象创建的时候被ARC默认加了`return [obj autorelease]`，就被放进AutoReleasePage啦

## __autorelease修饰符

- **`__autorelease` 修饰符并不像 weak 有个弱引用表，他不会被自动清理指针**
- __autorelease也是**强引用**

参考文档：

[[iOS] __autorelease的碎碎念&疑惑](https://www.jianshu.com/p/1a9847c5215b)

[[iOS] @autoreleasepool是干神马的](https://www.jianshu.com/p/b6cfbeabfb14)

## 应用场景

### 循环优化

```objective-c
for (int i = 0; i < 100000000; i++) {
  UIImage *image = [UIImage imageNamed:@"logo"];
}
```

这个内存爆的原因其实就是`image`作为**局部变量**，创建的是一个autorelease对象。产生了大量的autorelease对象，他们释放的时机，是最外部的autoreleasepool（此时，假设没有其他`autoreleasepool`修饰的话，就是主程序的`autoreleasepool`，那么就会等到下一个runloop再销毁）。在不特殊处理的时候会在runLoop休眠时再被销毁，不会立即销毁。

```objective-c
for (int i = 0; i < 100000000; i++) {
  @autoreleasepool{
    UIImage *image = [UIImage imageNamed:@"logo"];
  }
}
```

如果你的应用程序或者线程是要长期运行的，或者长期在后台中运行的任务，因为任务运行中runloop是不会休眠的，如果产生大量需要autorelease的对象，需要手动`@autoreleasepool`，否则不会立刻释放导致内存增加